diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7322e70..4325b31 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -237,8 +237,7 @@ endif(MINGW)
 ## Look for KDE and Qt ##
 #########################
 ########################
-
-find_package(ECM 5.19 REQUIRED NOMODULE)
+find_package(ECM 5.18 REQUIRED NOMODULE)
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${ECM_MODULE_PATH} ${ECM_KDE_MODULE_DIR})
 include(ECMOptionalAddSubdirectory)
 include(ECMAddAppIcon)
diff --git a/benchmarks/CMakeLists.txt b/benchmarks/CMakeLists.txt
index 01b8414..6ec34e9 100644
--- a/benchmarks/CMakeLists.txt
+++ b/benchmarks/CMakeLists.txt
@@ -38,7 +38,7 @@ set(kis_low_memory_benchmark_SRCS kis_low_memory_benchmark.cpp)
 set(KisAnimationRenderingBenchmark_SRCS KisAnimationRenderingBenchmark.cpp)
 set(kis_filter_selections_benchmark_SRCS kis_filter_selections_benchmark.cpp)
 if (UNIX)
-#        set(kis_composition_benchmark_SRCS kis_composition_benchmark.cpp)
+        set(kis_composition_benchmark_SRCS kis_composition_benchmark.cpp)
 endif()
 set(kis_thumbnail_benchmark_SRCS kis_thumbnail_benchmark.cpp)
 
@@ -60,7 +60,7 @@ krita_add_benchmark(KisLowMemoryBenchmark TESTNAME krita-benchmarks-KisLowMemory
 krita_add_benchmark(KisAnimationRenderingBenchmark TESTNAME krita-benchmarks-KisAnimationRenderingBenchmark ${KisAnimationRenderingBenchmark_SRCS})
 krita_add_benchmark(KisFilterSelectionsBenchmark TESTNAME krita-image-KisFilterSelectionsBenchmark ${kis_filter_selections_benchmark_SRCS})
 if(UNIX)
-#        krita_add_benchmark(KisCompositionBenchmark TESTNAME krita-benchmarks-KisComposition ${kis_composition_benchmark_SRCS})
+        krita_add_benchmark(KisCompositionBenchmark TESTNAME krita-benchmarks-KisComposition ${kis_composition_benchmark_SRCS})
 endif()
 krita_add_benchmark(KisThumbnailBenchmark TESTNAME krita-benchmarks-KisThumbnail ${kis_thumbnail_benchmark_SRCS})
 
@@ -82,9 +82,9 @@ target_link_libraries(KisAnimationRenderingBenchmark  kritaimage kritaui  Qt5::T
 target_link_libraries(KisFilterSelectionsBenchmark   kritaimage  Qt5::Test)
 
 if(UNIX)
-#    target_link_libraries(KisCompositionBenchmark  kritaimage  Qt5::Test ${LINK_VC_LIB})
+    target_link_libraries(KisCompositionBenchmark  kritaimage  Qt5::Test ${LINK_VC_LIB})
     if(HAVE_VC)
-#        set_property(TARGET KisCompositionBenchmark APPEND PROPERTY COMPILE_OPTIONS "${Vc_ARCHITECTURE_FLAGS}")
+        set_property(TARGET KisCompositionBenchmark APPEND PROPERTY COMPILE_OPTIONS "${Vc_ARCHITECTURE_FLAGS}")
     endif()
 endif()
 target_link_libraries(KisMaskGeneratorBenchmark  kritaimage  Qt5::Test)
diff --git a/benchmarks/kis_composition_benchmark.cpp b/benchmarks/kis_composition_benchmark.cpp
index 3925ee1..840c59b 100644
--- a/benchmarks/kis_composition_benchmark.cpp
+++ b/benchmarks/kis_composition_benchmark.cpp
@@ -652,6 +652,8 @@ void KisCompositionBenchmark::compareAlphaDarkenOps()
 
 void KisCompositionBenchmark::compareRgbF32AlphaDarkenOps()
 {
+    return;
+
     const KoColorSpace *cs = KoColorSpaceRegistry::instance()->colorSpace("RGBA", "F32", "");
     KoCompositeOp *opAct = KoOptimizedCompositeOpFactory::createAlphaDarkenOp128(cs);
     KoCompositeOp *opExp = new KoCompositeOpAlphaDarken<KoRgbF32Traits>(cs);
@@ -700,6 +702,8 @@ void KisCompositionBenchmark::compareOverOpsNoMask()
 
 void KisCompositionBenchmark::compareRgbF32OverOps()
 {
+    return;
+
     const KoColorSpace *cs = KoColorSpaceRegistry::instance()->colorSpace("RGBA", "F32", "");
     KoCompositeOp *opAct = KoOptimizedCompositeOpFactory::createOverOp128(cs);
     KoCompositeOp *opExp = new KoCompositeOpOver<KoRgbF32Traits>(cs);
@@ -919,7 +923,7 @@ void KisCompositionBenchmark::benchmarkFloatIntUint()
     using int_v = Vc::SimdArray<int, Vc::float_v::size()>;
     using uint_v = Vc::SimdArray<unsigned int, Vc::float_v::size()>;
 
-    const int dataSize = 4096;
+    const int dataSize = 1048576;
     void *ptr = 0;
     int error = MEMALIGN_ALLOC(&ptr, uint32VecAlignment, dataSize * sizeof(quint32));
     if (error) {
@@ -935,7 +939,11 @@ void KisCompositionBenchmark::benchmarkFloatIntUint()
     QBENCHMARK {
         for (int i = 0; i < dataSize; i += Vc::float_v::size()) {
             // conversion float -> int -> uint
-            uint_v b(int_v(Vc::float_v(fData + i)));
+            //uint_v b(int_v(Vc::round(fData + i)));
+            __m256 x = Vc::float_v(fData + i).data();
+            __m256i y = _mm256_cvtps_epi32(x);
+            int_v r(y);
+            uint_v b(r);
 
             b.store(iData + i);
         }
@@ -946,5 +954,24 @@ void KisCompositionBenchmark::benchmarkFloatIntUint()
 #endif
 }
 
+void KisCompositionBenchmark::testOfConversion()
+{
+#ifdef HAVE_VC
+    using int_v = Vc::SimdArray<int, Vc::float_v::size()>;
+
+    Vc::float_v v;
+    for (size_t i = 0; i < Vc::float_v::Size; ++i) {
+      v[i] = 3.14 + i;
+    }
+    QBENCHMARK {
+        __m256 x = v.data();
+        __m256i y = _mm256_cvtps_epi32(x);
+        int_v result(y);
+
+    }
+
+#endif
+}
+
 QTEST_MAIN(KisCompositionBenchmark)
 
diff --git a/benchmarks/kis_composition_benchmark.h b/benchmarks/kis_composition_benchmark.h
index 1f20ff0..5239599 100644
--- a/benchmarks/kis_composition_benchmark.h
+++ b/benchmarks/kis_composition_benchmark.h
@@ -30,21 +30,15 @@ private Q_SLOTS:
     void checkRoundingAlphaDarken_05_07();
     void checkRoundingAlphaDarken_05_10();
     void checkRoundingAlphaDarken_05_10_08();
-    void checkRoundingAlphaDarkenF32_05_03();
-    void checkRoundingAlphaDarkenF32_05_05();
-    void checkRoundingAlphaDarkenF32_05_07();
-    void checkRoundingAlphaDarkenF32_05_10();
-    void checkRoundingAlphaDarkenF32_05_10_08();
 
     void checkRoundingOver();
-    void checkRoundingOverRgbaF32();
 
     void compareAlphaDarkenOps();
     void compareAlphaDarkenOpsNoMask();
-    void compareRgbF32AlphaDarkenOps();
+
     void compareOverOps();
     void compareOverOpsNoMask();
-    void compareRgbF32OverOps();
+
 
     void testRgb8CompositeAlphaDarkenLegacy();
     void testRgb8CompositeAlphaDarkenOptimized();
@@ -52,11 +46,9 @@ private Q_SLOTS:
     void testRgb8CompositeOverLegacy();
     void testRgb8CompositeOverOptimized();
 
-    void testRgbF32CompositeAlphaDarkenLegacy();
-    void testRgbF32CompositeAlphaDarkenOptimized();
 
-    void testRgbF32CompositeOverLegacy();
-    void testRgbF32CompositeOverOptimized();
+
+
 
     void testRgb8CompositeAlphaDarkenReal_Aligned();
     void testRgb8CompositeOverReal_Aligned();
@@ -69,6 +61,21 @@ private Q_SLOTS:
     void benchmarkUintIntFloat();
     void benchmarkFloatUint();
     void benchmarkFloatIntUint();
+    void testOfConversion();
+
+private:
+    void compareRgbF32OverOps();
+    void checkRoundingAlphaDarkenF32_05_03();
+    void checkRoundingAlphaDarkenF32_05_05();
+    void checkRoundingAlphaDarkenF32_05_07();
+    void checkRoundingAlphaDarkenF32_05_10();
+    void checkRoundingAlphaDarkenF32_05_10_08();
+    void checkRoundingOverRgbaF32();
+    void compareRgbF32AlphaDarkenOps();
+    void testRgbF32CompositeAlphaDarkenLegacy();
+    void testRgbF32CompositeAlphaDarkenOptimized();
+    void testRgbF32CompositeOverLegacy();
+    void testRgbF32CompositeOverOptimized();
 };
 
 #endif /* __KIS_COMPOSITION_BENCHMARK_H */
diff --git a/libs/pigment/compositeops/KoOptimizedCompositeOpOver32.h b/libs/pigment/compositeops/KoOptimizedCompositeOpOver32.h
index a1b7861..2bfb12c 100644
--- a/libs/pigment/compositeops/KoOptimizedCompositeOpOver32.h
+++ b/libs/pigment/compositeops/KoOptimizedCompositeOpOver32.h
@@ -24,6 +24,7 @@
 #include "KoCompositeOpBase.h"
 #include "KoCompositeOpRegistry.h"
 #include "KoStreamedMath.h"
+#include "kis_debug.h"
 
 
 template<Vc::Implementation _impl>
@@ -192,10 +193,12 @@ struct OverCompositor32 {
                 }
             } else {
                 dstAlpha += (uint8Max - dstAlpha) * srcAlpha * uint8Rec1;
+
                 // Optimized version of:
                 //     srcBlendNorm = srcAlpha / dstAlpha);
                 srcBlendNorm = OptiDiv<_impl>::divScalar(srcAlpha, dstAlpha);
 
+
             }
 
             if(allChannelsFlag) {
diff --git a/libs/pigment/compositeops/KoStreamedMath.h b/libs/pigment/compositeops/KoStreamedMath.h
index 01fdde8..cf2dc17 100644
--- a/libs/pigment/compositeops/KoStreamedMath.h
+++ b/libs/pigment/compositeops/KoStreamedMath.h
@@ -47,6 +47,9 @@ struct KoStreamedMath {
 
 using int_v = Vc::SimdArray<int, Vc::float_v::size()>;
 using uint_v = Vc::SimdArray<unsigned int, Vc::float_v::size()>;
+using int32_16_v = Vc::SimdArray<qint32,  Vc::uint16_v::size()>;
+using uint32_16_v = Vc::SimdArray<quint32, Vc::uint16_v::size()>;
+using uint16_16_v = Vc::SimdArray<quint16, Vc::uint16_v::size()>;
 
 /**
  * Composes src into dst without using vector instructions
@@ -119,6 +122,11 @@ static inline Vc::float_v fetch_mask_8(const quint8 *data) {
     return Vc::float_v(int_v(data_i));
 }
 
+static inline Vc::uint16_v fetch_mask_8_uint16(const quint8 *data) {
+    Vc::uint16_v data_i(data);
+    return data_i;
+}
+
 /**
  * Get an alpha values from Vc::float_v::size() pixels 32-bit each
  * (4 channels, 8 bit per channel).  The alpha value is considered
@@ -143,6 +151,18 @@ static inline Vc::float_v fetch_alpha_32(const quint8 *data) {
     return Vc::float_v(int_v(data_i >> 24));
 }
 
+template <bool aligned>
+static inline uint16_16_v fetch_alpha_uint16(const quint8 *data) {
+    uint32_16_v data_i;
+   if (aligned) {
+       data_i.load((const quint32*)data, Vc::Aligned);
+   } else {
+       data_i.load((const quint32*)data, Vc::Unaligned);
+   }
+
+   return uint16_16_v(data_i >> 24);
+}
+
 /**
  * Get color values from Vc::float_v::size() pixels 32-bit each
  * (4 channels, 8 bit per channel).  The color data is considered
@@ -175,6 +195,26 @@ static inline void fetch_colors_32(const quint8 *data,
     c3 = Vc::float_v(int_v( data_i        & mask));
 }
 
+template <bool aligned>
+static inline void fetch_colors_uint16(const quint8 *data,
+                            Vc::uint16_v &c1,
+                            Vc::uint16_v &c2,
+                            Vc::uint16_v &c3) {
+    Vc::uint32_v data_i;
+    if (aligned) {
+        data_i.load((const quint32*)data, Vc::Aligned);
+    } else {
+        data_i.load((const quint32*)data, Vc::Unaligned);
+    }
+
+    const quint32 lowByteMask = 0xFF;
+    Vc::uint32_v mask(lowByteMask);
+
+    c1 = Vc::uint16_v((data_i >> 16) & mask);
+    c2 = Vc::uint16_v((data_i >> 8)  & mask);
+    c3 = Vc::uint16_v(data_i         & mask);
+}
+
 /**
  * Pack color and alpha values to Vc::float_v::size() pixels 32-bit each
  * (4 channels, 8 bit per channel).  The color data is considered
@@ -199,10 +239,28 @@ static inline void write_channels_32(quint8 *data,
     //        The achieve that we need to implement Vc::iRound()
 
     uint_v mask(lowByteMask);
-    uint_v v1 = uint_v(int_v(Vc::round(alpha))) << 24;
-    uint_v v2 = (uint_v(int_v(Vc::round(c1))) & mask) << 16;
-    uint_v v3 = (uint_v(int_v(Vc::round(c2))) & mask) <<  8;
-    uint_v v4 = uint_v(int_v(Vc::round(c3))) & mask;
+    //uint_v v1 =  uint_v(Vc::iround(alpha)) << 24;  //
+    uint_v v1 =  uint_v(int_v(round(alpha))) << 24;
+    uint_v v2 = (uint_v(int_v(Vc::round(c1))) & mask) << 16; //
+    uint_v v3 = (uint_v(int_v(Vc::round(c2))) & mask) <<  8; //
+    uint_v v4 = uint_v(int_v(Vc::round(c3)))  & mask; //
+    v1 = v1 | v2;
+    v3 = v3 | v4;
+    (v1 | v3).store((quint32*)data, Vc::Aligned); //SEG foult
+}
+
+static inline void write_channels_uint16(quint8 *data,
+                                     Vc::uint16_v::AsArg alpha,
+                                     Vc::uint16_v::AsArg c1,
+                                     Vc::uint16_v::AsArg c2,
+                                     Vc::uint16_v::AsArg c3) {
+    const quint32 lowByteMask = 0xFF;
+
+    uint32_16_v mask(lowByteMask);
+    uint32_16_v v1 =   uint32_16_v(round(alpha)) << 24;
+    uint32_16_v v2 = ( uint32_16_v(Vc::round(c1)) & mask) << 16;
+    uint32_16_v v3 = ( uint32_16_v(Vc::round(c2)) & mask) <<  8;
+    uint32_16_v v4 =  uint32_16_v(Vc::round(c3))  & mask;
     v1 = v1 | v2;
     v3 = v3 | v4;
     (v1 | v3).store((quint32*)data, Vc::Aligned);
@@ -213,12 +271,12 @@ static inline void write_channels_32(quint8 *data,
  * colorspaces. Uses \p Compositor strategy parameter for doing actual
  * math of the composition
  */
-template<bool useMask, bool useFlow, class Compositor, int pixelSize>
+template<bool useMask, bool useFlow, class Compositor, int pixelSize, int vectorSize>
     static void genericComposite(const KoCompositeOp::ParameterInfo& params)
 {
     using namespace Arithmetic;
 
-    const int vectorSize = Vc::float_v::size();
+    //const int vectorSize = Vc::float_v::size();
     const qint32 vectorInc = pixelSize * vectorSize;
     const qint32 linearInc = pixelSize;
     qint32 srcVectorInc = vectorInc;
@@ -372,13 +430,13 @@ template<bool useMask, bool useFlow, class Compositor, int pixelSize>
 template<bool useMask, bool useFlow, class Compositor>
     static void genericComposite32(const KoCompositeOp::ParameterInfo& params)
 {
-    genericComposite<useMask, useFlow, Compositor, 4>(params);
+    genericComposite<useMask, useFlow, Compositor, 4, Vc::uint16_v::size()>(params);
 }
 
 template<bool useMask, bool useFlow, class Compositor>
     static void genericComposite128(const KoCompositeOp::ParameterInfo& params)
 {
-    genericComposite<useMask, useFlow, Compositor, 16>(params);
+    genericComposite<useMask, useFlow, Compositor, 16, Vc::float_v::size()>(params);
 }
 
 };
diff --git a/libs/pigment/compositeops/KoVcMultiArchBuildSupport.h b/libs/pigment/compositeops/KoVcMultiArchBuildSupport.h
index 2bdd069..8180c8b 100644
--- a/libs/pigment/compositeops/KoVcMultiArchBuildSupport.h
+++ b/libs/pigment/compositeops/KoVcMultiArchBuildSupport.h
@@ -21,6 +21,9 @@
 #define __KOVCMULTIARCHBUILDSUPPORT_H
 
 #include "config-vc.h"
+#include "kis_debug.h"
+
+//#define HAVE_VC 1
 
 #ifdef HAVE_VC
 
@@ -70,6 +73,9 @@ template<class FactoryType>
 typename FactoryType::ReturnType
 createOptimizedClass(typename FactoryType::ParamType param)
 {
+    // in c-tor of one of the factories
+    //qDebug() << ppVar(Vc::CurrentImplementation::current());
+
     static bool isConfigInitialized = false;
     static bool useVectorization = true;
 
diff --git a/libs/pigment/compositeops/kis_composition_benchmark b/libs/pigment/compositeops/kis_composition_benchmark
new file mode 100644
index 0000000..e69de29
diff --git a/libs/pigment/compositeops/vector.h b/libs/pigment/compositeops/vector.h
new file mode 100644
index 0000000..e69de29
diff --git a/libs/pigment/tests/CMakeLists.txt b/libs/pigment/tests/CMakeLists.txt
index 910e13e..9307538 100644
--- a/libs/pigment/tests/CMakeLists.txt
+++ b/libs/pigment/tests/CMakeLists.txt
@@ -9,6 +9,14 @@ if(MSVC OR (WIN32 AND "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Intel"))
   set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /NODEFAULTLIB:LIBC.LIB")
 endif()
 
+macro_add_unittest_definitions()
+
+set(TestColorBlendingSources TestColorBlending.cpp)
+ki18n_wrap_ui(TestColorBlendingSources TestColorBlendingWindow.ui)
+add_executable(TestColorBlending ${TestColorBlendingSources})
+target_link_libraries(TestColorBlending kritaimage)
+
+
 ecm_add_tests(
     TestKoColorSpaceRegistry.cpp
     TestKoColorSpaceAbstract.cpp
@@ -27,6 +35,7 @@ ecm_add_tests(
 ecm_add_tests(
     TestColorConversion.cpp
     TestKoColorSpaceMaths.cpp
+    TestColorBlending.cpp
 
     NAME_PREFIX "libs-pigment-"
     LINK_LIBRARIES kritapigment Qt5::Test)
diff --git a/libs/pigment/tests/TestColorBlending.cpp b/libs/pigment/tests/TestColorBlending.cpp
new file mode 100644
index 0000000..1170429
--- /dev/null
+++ b/libs/pigment/tests/TestColorBlending.cpp
@@ -0,0 +1,645 @@
+#include "TestColorBlending.h"
+
+#include <QTest>
+#include <KoColorSpace.h>
+#include <KoCompositeOp.h>
+#include <KoColorSpaceRegistry.h>
+#include <KoColorSpaceTraits.h>
+#include <kis_debug.h>
+
+
+#if defined _MSC_VER
+#define MEMALIGN_ALLOC(p, a, s) ((*(p)) = _aligned_malloc((s), (a)), *(p) ? 0 : errno)
+#define MEMALIGN_FREE(p) _aligned_free((p))
+#else
+#define MEMALIGN_ALLOC(p, a, s) posix_memalign((p), (a), (s))
+#define MEMALIGN_FREE(p) free((p))
+#endif
+
+
+const int alpha_pos = 3;
+
+enum AlphaRange {
+    ALPHA_ZERO,
+    ALPHA_UNIT,
+    ALPHA_RANDOM
+};
+
+
+template <typename channel_type, class RandomGenerator>
+inline channel_type generateAlphaValue(AlphaRange range, RandomGenerator &rnd) {
+    channel_type value = 0;
+
+    switch (range) {
+    case ALPHA_ZERO:
+        break;
+    case ALPHA_UNIT:
+        value = rnd.unit();
+        break;
+    case ALPHA_RANDOM:
+        value = rnd();
+        break;
+    }
+
+    return value;
+}
+
+#include <boost/random/mersenne_twister.hpp>
+#include <boost/random/uniform_smallint.hpp>
+#include <boost/random/uniform_real.hpp>
+
+template <typename channel_type>
+struct RandomGenerator {
+    channel_type operator() () {
+        qFatal("Wrong template instantiation");
+        return channel_type(0);
+    }
+
+    channel_type unit() {
+        qFatal("Wrong template instantiation");
+        return channel_type(0);
+    }
+};
+
+template <>
+struct RandomGenerator<quint8>
+{
+    RandomGenerator(int seed)
+        : m_smallint(0,255),
+          m_rnd(seed)
+    {
+    }
+
+    quint8 operator() () {
+        return m_smallint(m_rnd);
+    }
+
+    quint8 unit() {
+        return KoColorSpaceMathsTraits<quint8>::unitValue;
+    }
+
+    boost::uniform_smallint<int> m_smallint;
+    boost::mt11213b m_rnd;
+};
+
+
+template <>
+struct RandomGenerator<quint16>
+{
+    RandomGenerator(int seed)
+        : m_smallint(0,255),
+          m_rnd(seed)
+    {
+    }
+
+    quint16 operator() () {
+        return m_smallint(m_rnd);
+    }
+
+    quint16 unit() {
+        return KoColorSpaceMathsTraits<quint16>::unitValue;
+    }
+
+    boost::uniform_smallint<int> m_smallint;
+    boost::mt11213b m_rnd;
+};
+
+template <>
+struct RandomGenerator<float>
+{
+    RandomGenerator(int seed)
+        : m_rnd(seed)
+    {
+    }
+
+    float operator() () {
+        //return float(m_rnd()) / float(m_rnd.max());
+        return m_smallfloat(m_rnd);
+    }
+
+    float unit() {
+        return KoColorSpaceMathsTraits<float>::unitValue;
+    }
+
+    boost::uniform_real<float> m_smallfloat;
+    boost::mt11213b m_rnd;
+};
+
+template <>
+struct RandomGenerator<double> : RandomGenerator<float>
+{
+    RandomGenerator(int seed)
+        : RandomGenerator<float>(seed)
+    {
+    }
+};
+
+
+template <typename channel_type>
+void generateDataLine(uint seed, int numPixels, quint8 *srcPixels, quint8 *dstPixels, quint8 *mask, AlphaRange srcAlphaRange, AlphaRange dstAlphaRange)
+{
+    Q_ASSERT(numPixels >= 4);
+
+    RandomGenerator<channel_type> rnd(seed);
+    RandomGenerator<quint8> maskRnd(seed + 1);
+
+    channel_type *srcArray = reinterpret_cast<channel_type*>(srcPixels);
+    channel_type *dstArray = reinterpret_cast<channel_type*>(dstPixels);
+
+    for (int i = 0; i < numPixels; i++) {
+        for (int j = 0; j < 3; j++) {
+            channel_type s = rnd();
+            channel_type d = rnd();
+            *(srcArray++) = s;
+            *(dstArray++) = d;
+        }
+
+        channel_type sa = generateAlphaValue<channel_type>(srcAlphaRange, rnd);
+        channel_type da = generateAlphaValue<channel_type>(dstAlphaRange, rnd);
+        *(srcArray++) = sa;
+        *(dstArray++) = da;
+
+        *(mask++) = maskRnd();
+    }
+}
+
+void printData(int numPixels, quint8 *srcPixels, quint8 *dstPixels, quint8 *mask)
+{
+    for (int i = 0; i < numPixels; i++) {
+        qDebug() << "Src: "
+                 << srcPixels[i*4] << "\t"
+                 << srcPixels[i*4+1] << "\t"
+                 << srcPixels[i*4+2] << "\t"
+                 << srcPixels[i*4+3] << "\t"
+                 << "Msk:" << mask[i];
+
+        qDebug() << "Dst: "
+                 << dstPixels[i*4] << "\t"
+                 << dstPixels[i*4+1] << "\t"
+                 << dstPixels[i*4+2] << "\t"
+                 << dstPixels[i*4+3];
+    }
+}
+
+const int rowStride = 64;
+const int totalRows = 64;
+const QRect processRect(0,0,64,64);
+const int numPixels = rowStride * totalRows;
+const int numTiles = 1024;
+
+
+struct Tile {
+    quint8 *src;
+    quint8 *dst;
+    quint8 *mask;
+};
+#include <stdint.h>
+QVector<Tile> generateTiles(int size,
+                            const int srcAlignmentShift,
+                            const int dstAlignmentShift,
+                            AlphaRange srcAlphaRange,
+                            AlphaRange dstAlphaRange,
+                            const quint32 pixelSize)
+{
+    QVector<Tile> tiles(size);
+
+#ifdef HAVE_VC
+    const int vecSize = Vc::uint16_v::size();
+#else
+    const int vecSize = 1;
+#endif
+
+    // the 256 are used to make sure that we have a good alignment no matter what build options are used.
+    const size_t pixelAlignment = qMax(size_t(vecSize * sizeof(quint16)), size_t(256));
+    const size_t maskAlignment = qMax(size_t(vecSize), size_t(256));
+    for (int i = 0; i < size; i++) {
+        void *ptr = 0;
+        int error = MEMALIGN_ALLOC(&ptr, pixelAlignment, numPixels * pixelSize + srcAlignmentShift);
+        if (error) {
+            qFatal("posix_memalign failed: %d", error);
+        }
+        tiles[i].src = (quint8*)ptr + srcAlignmentShift;
+        error = MEMALIGN_ALLOC(&ptr, pixelAlignment, numPixels * pixelSize + dstAlignmentShift);
+        if (error) {
+            qFatal("posix_memalign failed: %d", error);
+        }
+        tiles[i].dst = (quint8*)ptr + dstAlignmentShift;
+        error = MEMALIGN_ALLOC(&ptr, maskAlignment, numPixels);
+        if (error) {
+            qFatal("posix_memalign failed: %d", error);
+        }
+        tiles[i].mask = (quint8*)ptr;
+
+        if (pixelSize == 4) {
+            generateDataLine<quint8>(1, numPixels, tiles[i].src, tiles[i].dst, tiles[i].mask, srcAlphaRange, dstAlphaRange);
+        } else if (pixelSize == 16) {
+            generateDataLine<quint16>(1, numPixels, tiles[i].src, tiles[i].dst, tiles[i].mask, srcAlphaRange, dstAlphaRange);
+        } else {
+            qFatal("Pixel size %i is not implemented", pixelSize);
+        }
+    }
+
+    return tiles;
+}
+
+void freeTiles(QVector<Tile> tiles,
+               const int srcAlignmentShift,
+               const int dstAlignmentShift)
+{
+    Q_FOREACH (const Tile &tile, tiles) {
+        MEMALIGN_FREE(tile.src - srcAlignmentShift);
+        MEMALIGN_FREE(tile.dst - dstAlignmentShift);
+        MEMALIGN_FREE(tile.mask);
+    }
+}
+
+template <typename channel_type>
+inline bool fuzzyCompare(channel_type a, channel_type b, channel_type prec) {
+    return qAbs(a - b) <= prec;
+}
+
+template <typename channel_type>
+inline bool comparePixels(channel_type *p1, channel_type *p2, channel_type prec) {
+    return (p1[3] == p2[3] && p1[3] == 0) ||
+        (fuzzyCompare(p1[0], p2[0], prec) &&
+         fuzzyCompare(p1[1], p2[1], prec) &&
+         fuzzyCompare(p1[2], p2[2], prec) &&
+         fuzzyCompare(p1[3], p2[3], prec));
+}
+
+template <typename channel_type>
+bool compareTwoOpsPixels(QVector<Tile> &tiles, channel_type prec) {
+    channel_type *dst1 = reinterpret_cast<channel_type*>(tiles[0].dst);
+    channel_type *dst2 = reinterpret_cast<channel_type*>(tiles[1].dst);
+
+    channel_type *src1 = reinterpret_cast<channel_type*>(tiles[0].src);
+    channel_type *src2 = reinterpret_cast<channel_type*>(tiles[1].src);
+
+    for (int i = 0; i < numPixels; i++) {
+        if (!comparePixels<channel_type>(dst1, dst2, prec)) {
+            qDebug() << "Wrong result:" << i;
+            qDebug() << "Act: " << dst1[0] << dst1[1] << dst1[2] << dst1[3];
+            qDebug() << "Exp: " << dst2[0] << dst2[1] << dst2[2] << dst2[3];
+            qDebug() << "Dif: " << dst1[0] - dst2[0] << dst1[1] - dst2[1] << dst1[2] - dst2[2] << dst1[3] - dst2[3];
+
+            channel_type *s1 = src1 + 4 * i;
+            channel_type *s2 = src2 + 4 * i;
+
+            qDebug() << "SrcA:" << s1[0] << s1[1] << s1[2] << s1[3];
+            qDebug() << "SrcE:" << s2[0] << s2[1] << s2[2] << s2[3];
+
+            qDebug() << "MskA:" << tiles[0].mask[i];
+            qDebug() << "MskE:" << tiles[1].mask[i];
+
+            return false;
+        }
+        dst1 += 4;
+        dst2 += 4;
+    }
+    return true;
+}
+
+bool compareTwoOps(bool haveMask, const KoCompositeOp *op1, const KoCompositeOp *op2)
+{
+    Q_ASSERT(op1->colorSpace()->pixelSize() == op2->colorSpace()->pixelSize());
+    const quint32 pixelSize = op1->colorSpace()->pixelSize();
+    const int alignment = 16;
+    QVector<Tile> tiles = generateTiles(2, alignment, alignment, ALPHA_RANDOM, ALPHA_RANDOM, op1->colorSpace()->pixelSize());
+
+    KoCompositeOp::ParameterInfo params;
+    params.dstRowStride  = 4 * rowStride;
+    params.srcRowStride  = 4 * rowStride;
+    params.maskRowStride = rowStride;
+    params.rows          = processRect.height();
+    params.cols          = processRect.width();
+    // This is a hack as in the old version we get a rounding of opacity to this value
+    params.opacity       = quint16(Arithmetic::scale<quint8>(0.5*1.0f))/255.0;
+    params.flow          = 0.3*1.0f;
+    params.channelFlags  = QBitArray();
+
+    params.dstRowStart   = tiles[0].dst;
+    params.srcRowStart   = tiles[0].src;
+    params.maskRowStart  = haveMask ? tiles[0].mask : 0;
+    op1->composite(params);
+
+    params.dstRowStart   = tiles[1].dst;
+    params.srcRowStart   = tiles[1].src;
+    params.maskRowStart  = haveMask ? tiles[1].mask : 0;
+    op2->composite(params);
+
+    bool compareResult = true;
+    if (pixelSize == 4) {
+        compareResult = compareTwoOpsPixels<quint8>(tiles, 10);
+    }
+    else if (pixelSize == 16) {
+        compareResult = compareTwoOpsPixels<quint16>(tiles, 2e-7);
+    }
+    else {
+        qFatal("Pixel size %i is not implemented", pixelSize);
+    }
+
+    freeTiles(tiles, alignment, alignment);
+
+    return compareResult;
+}
+
+QString getTestName(bool haveMask,
+                    const int srcAlignmentShift,
+                    const int dstAlignmentShift,
+                    AlphaRange srcAlphaRange,
+                    AlphaRange dstAlphaRange)
+{
+
+    QString testName;
+    testName +=
+        !srcAlignmentShift && !dstAlignmentShift ? "Aligned   " :
+        !srcAlignmentShift &&  dstAlignmentShift ? "SrcUnalig " :
+         srcAlignmentShift && !dstAlignmentShift ? "DstUnalig " :
+         srcAlignmentShift &&  dstAlignmentShift ? "Unaligned " : "###";
+
+    testName += haveMask ? "Mask   " : "NoMask ";
+
+    testName +=
+        srcAlphaRange == ALPHA_RANDOM ? "SrcRand " :
+        srcAlphaRange == ALPHA_ZERO   ? "SrcZero " :
+        srcAlphaRange == ALPHA_UNIT   ? "SrcUnit " : "###";
+
+    testName +=
+        dstAlphaRange == ALPHA_RANDOM ? "DstRand" :
+        dstAlphaRange == ALPHA_ZERO   ? "DstZero" :
+        dstAlphaRange == ALPHA_UNIT   ? "DstUnit" : "###";
+
+    return testName;
+}
+
+void benchmarkCompositeOp(const KoCompositeOp *op,
+                          bool haveMask,
+                          qreal opacity,
+                          qreal flow,
+                          const int srcAlignmentShift,
+                          const int dstAlignmentShift,
+                          AlphaRange srcAlphaRange,
+                          AlphaRange dstAlphaRange)
+{
+    QString testName = getTestName(haveMask, srcAlignmentShift, dstAlignmentShift, srcAlphaRange, dstAlphaRange);
+
+    QVector<Tile> tiles =
+        generateTiles(numTiles, srcAlignmentShift, dstAlignmentShift, srcAlphaRange, dstAlphaRange, op->colorSpace()->pixelSize());
+
+    const int tileOffset = 4 * (processRect.y() * rowStride + processRect.x());
+
+    KoCompositeOp::ParameterInfo params;
+    params.dstRowStride  = 4 * rowStride;
+    params.srcRowStride  = 4 * rowStride;
+    params.maskRowStride = rowStride;
+    params.rows          = processRect.height();
+    params.cols          = processRect.width();
+    params.opacity       = opacity;
+    params.flow          = flow;
+    params.channelFlags  = QBitArray();
+
+    QTime timer;
+    timer.start();
+
+    Q_FOREACH (const Tile &tile, tiles) {
+        params.dstRowStart   = tile.dst + tileOffset;
+        params.srcRowStart   = tile.src + tileOffset;
+        params.maskRowStart  = haveMask ? tile.mask : 0;
+        op->composite(params);
+    }
+
+    qDebug() << testName << "RESULT:" << timer.elapsed() << "msec";
+
+    freeTiles(tiles, srcAlignmentShift, dstAlignmentShift);
+}
+
+void benchmarkCompositeOp(const KoCompositeOp *op, const QString &postfix)
+{
+    qDebug() << "Testing Composite Op:" << op->id() << "(" << postfix << ")";
+
+    benchmarkCompositeOp(op, true, 0.5, 0.3, 0, 0, ALPHA_RANDOM, ALPHA_RANDOM);
+    benchmarkCompositeOp(op, true, 0.5, 0.3, 8, 0, ALPHA_RANDOM, ALPHA_RANDOM);
+    benchmarkCompositeOp(op, true, 0.5, 0.3, 0, 8, ALPHA_RANDOM, ALPHA_RANDOM);
+    benchmarkCompositeOp(op, true, 0.5, 0.3, 4, 8, ALPHA_RANDOM, ALPHA_RANDOM);
+
+/// --- Vary the content of the source and destination
+
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_RANDOM, ALPHA_RANDOM);
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_ZERO, ALPHA_RANDOM);
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_UNIT, ALPHA_RANDOM);
+
+/// ---
+
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_RANDOM, ALPHA_ZERO);
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_ZERO, ALPHA_ZERO);
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_UNIT, ALPHA_ZERO);
+
+/// ---
+
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_RANDOM, ALPHA_UNIT);
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_ZERO, ALPHA_UNIT);
+    benchmarkCompositeOp(op, false, 1.0, 1.0, 0, 0, ALPHA_UNIT, ALPHA_UNIT);
+}
+
+
+
+void TestColorBlending::init() {
+    qApp->setApplicationName("krita");
+    // All Krita's resource types
+    KoResourcePaths::addResourceType("kis_pics", "data", "/pics/");
+    KoResourcePaths::addResourceType("kis_images", "data", "/images/");
+    KoResourcePaths::addResourceType("icc_profiles", "data", "/profiles/");
+    KoResourcePaths::addResourceType("metadata_schema", "data", "/metadata/schemas/");
+    KoResourcePaths::addResourceType("kis_brushes", "data", "/brushes/");
+    KoResourcePaths::addResourceType("kis_taskset", "data", "/taskset/");
+    KoResourcePaths::addResourceType("kis_taskset", "data", "/taskset/");
+    KoResourcePaths::addResourceType("gmic_definitions", "data", "/gmic/");
+    KoResourcePaths::addResourceType("kis_resourcebundles", "data", "/bundles/");
+    KoResourcePaths::addResourceType("kis_defaultpresets", "data", "/defaultpresets/");
+    KoResourcePaths::addResourceType("kis_paintoppresets", "data", "/paintoppresets/");
+    KoResourcePaths::addResourceType("kis_workspaces", "data", "/workspaces/");
+    KoResourcePaths::addResourceType("psd_layer_style_collections", "data", "/asl");
+    KoResourcePaths::addResourceType("ko_patterns", "data", "/patterns/", true);
+    KoResourcePaths::addResourceType("ko_gradients", "data", "/gradients/");
+    KoResourcePaths::addResourceType("ko_gradients", "data", "/gradients/", true);
+    KoResourcePaths::addResourceType("ko_palettes", "data", "/palettes/", true);
+    KoResourcePaths::addResourceType("kis_shortcuts", "data", "/shortcuts/");
+    KoResourcePaths::addResourceType("kis_actions", "data", "/actions");
+    KoResourcePaths::addResourceType("icc_profiles", "data", "/color/icc");
+    KoResourcePaths::addResourceType("ko_effects", "data", "/effects/");
+    KoResourcePaths::addResourceType("tags", "data", "/tags/");
+    KoResourcePaths::addResourceType("templates", "data", "/templates");
+    KoResourcePaths::addResourceType("pythonscripts", "data", "/pykrita");
+    KoResourcePaths::addResourceType("symbols", "data", "/symbols");
+
+    //    // Extra directories to look for create resources. (Does anyone actually use that anymore?)
+    //    KoResourcePaths::addResourceDir("ko_gradients", "/usr/share/create/gradients/gimp");
+    //    KoResourcePaths::addResourceDir("ko_gradients", QDir::homePath() + QString("/.create/gradients/gimp"));
+    //    KoResourcePaths::addResourceDir("ko_patterns", "/usr/share/create/patterns/gimp");
+    //    KoResourcePaths::addResourceDir("ko_patterns", QDir::homePath() + QString("/.create/patterns/gimp"));
+    //    KoResourcePaths::addResourceDir("kis_brushes", "/usr/share/create/brushes/gimp");
+    //    KoResourcePaths::addResourceDir("kis_brushes", QDir::homePath() + QString("/.create/brushes/gimp"));
+    //    KoResourcePaths::addResourceDir("ko_palettes", "/usr/share/create/swatches");
+    //    KoResourcePaths::addResourceDir("ko_palettes", QDir::homePath() + QString("/.create/swatches"));
+
+    // Make directories for all resources we can save, and tags
+    QDir d;
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/tags/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/asl/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/bundles/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/gradients/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/paintoppresets/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/palettes/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/patterns/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/taskset/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/workspaces/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/input/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/pykrita/");
+    d.mkpath(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation) + "/symbols/");
+
+    // Indicate that it is now safe for users of KoResourcePaths to load resources
+    KoResourcePaths::setReady();
+
+}
+
+
+void TestColorBlending::benchmark()
+{
+    const KoColorSpace *cs = KoColorSpaceRegistry::instance()->rgb8();
+    KoCompositeOp *op = new KoDoubleOptimizedCompositeOpOver32<Vc::CurrentImplementation::current()>(cs);
+    benchmarkCompositeOp(op, "DoupleOptimized");
+    delete op;
+}
+
+void TestColorBlending::compareOverOps()
+{
+    const KoColorSpace *cs = KoColorSpaceRegistry::instance()->rgb8();
+    KoCompositeOp *opAct = KoOptimizedCompositeOpFactory::createOverOp32(cs);
+    KoCompositeOp *opExp = new KoDoubleOptimizedCompositeOpOver32<Vc::CurrentImplementation::current()>(cs);
+
+    QVERIFY(compareTwoOps(true, opAct, opExp));
+
+    delete opExp;
+    delete opAct;
+}
+
+//void TestColorBlending::compareOverOpsNoMask()
+//{
+//    const KoColorSpace *cs = KoColorSpaceRegistry::instance()->rgb8();
+//    KoCompositeOp *opAct = KoOptimizedCompositeOpFactory::createOverOp32(cs);
+//    KoCompositeOp *opExp = new KoDoubleOptimizedCompositeOpOver32<Vc::CurrentImplementation::current()>(cs);
+
+//    QVERIFY(compareTwoOps(false, opAct, opExp));
+
+//    delete opExp;
+//    delete opAct;
+//}
+
+
+//void TestColorBlending::mask_test()
+//{
+//    Vc::uint8_v v;
+//    v[0] = ; v[1] = 240; v[2] = 38; v[3] = 70;
+//    Vc::uint16_v mask1 = KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_mask_8_uint16((quint8*)&v);
+//    Vc::float_v mask2 = KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_mask_8((quint8*)&v);
+//    qDebug() << "Mymask:" << mask1[0] << mask1[1] << mask1[2] << mask1[3];
+//    qDebug() << "Optmask:" << mask2[0] << mask2[1] << mask2[2] << mask2[3];
+
+//}
+
+
+
+//void TestColorBlending::alpha_test()
+//{
+//    Vc::uint8_v v;
+//    v[0] = 56; v[1] = 240; v[2] = 38; v[3] = 80;
+//    Vc::uint16_v mask1 = KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_alpha_uint16<true>((quint8*)&v);
+//    Vc::float_v mask2 = KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_alpha_32<true>((quint8*)&v);
+//    qDebug() << "Myalpha:" << mask1[0] << mask1[1] << mask1[2] << mask1[3];
+//    qDebug() << "Optalpha:" << mask2[0] << mask2[1] << mask2[2] << mask2[3];
+
+//    mask1 = KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_alpha_uint16<false>((quint8*)&v);
+//    mask2 = KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_alpha_32<false>((quint8*)&v);
+//    qDebug() << "Myalpha:" << mask1[0] << mask1[1] << mask1[2] << mask1[3];
+//    qDebug() << "Optalpha:" << mask2[0] << mask2[1] << mask2[2] << mask2[3];
+
+//}
+
+
+//void TestColorBlending::colors_test()
+//{
+//    Vc::uint8_v v;
+//    v[0] = 56;
+//    v[1] = 240;
+//    v[2] = 38;
+//    v[3] = 80;
+//    Vc::float_v src_c1;
+//    Vc::float_v src_c2;
+//    Vc::float_v src_c3;
+
+//    Vc::uint16_v src_c4;
+//    Vc::uint16_v src_c5;
+//    Vc::uint16_v src_c6;
+//    KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_colors_32<true>((quint8*)&v, src_c1, src_c2, src_c3);
+//    qDebug() << "OptColor1:" << src_c1[0] << src_c1[1] << src_c1[2] << src_c1[3];
+//    qDebug() << "OptColor2:" << src_c2[0] << src_c2[1] << src_c2[2] << src_c2[3];
+//    qDebug() << "OptColor3:" << src_c3[0] << src_c3[1] << src_c3[2] << src_c3[3];
+
+//    KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_colors_uint16<true>((quint8*)&v, src_c4, src_c5, src_c6);
+//    qDebug() << "MyColor1:" << src_c4[0] << src_c4[1] << src_c4[2] << src_c4[3];
+//    qDebug() << "MyColor2:" << src_c5[0] << src_c5[1] << src_c5[2] << src_c5[3];
+//    qDebug() << "MyColor3:" << src_c6[0] << src_c6[1] << src_c6[2] << src_c6[3];
+
+//    KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_colors_32<false>((quint8*)&v, src_c1, src_c2, src_c3);
+//    qDebug() << "OptColor1:" << src_c1[0] << src_c1[1] << src_c1[2] << src_c1[3];
+//    qDebug() << "OptColor2:" << src_c2[0] << src_c2[1] << src_c2[2] << src_c2[3];
+//    qDebug() << "OptColor3:" << src_c3[0] << src_c3[1] << src_c3[2] << src_c3[3];
+
+//    KoStreamedMath<Vc::CurrentImplementation::current()>::fetch_colors_uint16<false>((quint8*)&v, src_c4, src_c5, src_c6);
+//    qDebug() << "MyColor1:" << src_c4[0] << src_c4[1] << src_c4[2] << src_c4[3];
+//    qDebug() << "MyColor2:" << src_c5[0] << src_c5[1] << src_c5[2] << src_c5[3];
+//    qDebug() << "MyColor3:" << src_c6[0] << src_c6[1] << src_c6[2] << src_c6[3];
+
+
+
+//}
+
+
+//void TestColorBlending::channels_test()
+//{
+//    Vc::float_v src_alpha;src_alpha[0] = 46; src_alpha[1] = 0; src_alpha[2] = 0; src_alpha[3] = 0;
+//    Vc::float_v src_c1;src_c1[0] = 54; src_c1[1] = 0; src_c1[2] = 0; src_c1[3] = 0;
+//    Vc::float_v src_c2;src_c2[0] = 144; src_c2[1] = 0; src_c2[2] = 0; src_c2[3] = 0;
+//    Vc::float_v src_c3;src_c3[0] = 233; src_c3[1] = 0; src_c3[2] = 0; src_c3[3] = 0;
+
+//    Vc::uint16_v dst_alpha;dst_alpha[0] = 46; dst_alpha[1] = 0; dst_alpha[2] = 0; dst_alpha[3] = 0;
+//    Vc::uint16_v dst_c1;dst_c1[0] = 54; dst_c1[1] = 0; dst_c1[2] = 0; dst_c1[3] = 0;
+//    Vc::uint16_v dst_c2;dst_c2[0] = 144; dst_c2[1] = 0; dst_c2[2] = 0; dst_c2[3] = 0;
+//    Vc::uint16_v dst_c3;dst_c3[0] = 233; dst_c3[1] = 0; dst_c3[2] = 0; dst_c3[3] = 0;
+
+//    Vc::uint8_v v;
+//    v[0] = 56;
+//    v[1] = 240;
+//    v[2] = 38;
+//    v[3] = 80;
+
+//    Vc::uint8_v w;
+//    w[0] = 56;
+//    w[1] = 240;
+//    w[2] = 38;
+//    w[3] = 80;
+
+//    KoStreamedMath<Vc::CurrentImplementation::current()>::write_channels_32((quint8*)&v, src_alpha, src_c1, src_c2, src_c3);
+
+//    qDebug() << "OptChannel:" << v[0] << v[1] << v[2] << v[3];
+
+//    KoStreamedMath<Vc::CurrentImplementation::current()>::write_channels_uint16((quint8*)&w, dst_alpha,dst_c1, dst_c2, dst_c3);
+//    qDebug() << "MyChannel:" << w[0] << w[1] << w[2] << w[3];
+
+
+
+//}
+
+
+QTEST_MAIN(TestColorBlending)
+
diff --git a/libs/pigment/tests/TestColorBlending.h b/libs/pigment/tests/TestColorBlending.h
new file mode 100644
index 0000000..e8159dd
--- /dev/null
+++ b/libs/pigment/tests/TestColorBlending.h
@@ -0,0 +1,282 @@
+#ifndef TESTCOLORBLENDING_H
+#define TESTCOLORBLENDING_H
+
+#include <QtTest>
+#include "ui_TestColorBlendingWindow.h"
+#include <cmath>
+#include <limits>
+
+#include "kritapigment_export.h"
+#include "KoCompositeOpBase.h"
+#include "KoCompositeOpRegistry.h"
+#include "KoStreamedMath.h"
+#include "KoOptimizedCompositeOpOver32.h"
+#include "KoOptimizedCompositeOpFactory.h"
+#include <kis_debug.h>
+#include "KoResourcePaths.h"
+
+
+class TestColorBlending : public QObject
+{
+    Q_OBJECT
+private Q_SLOTS:
+    void init();
+    void benchmark();
+    void compareOverOps();
+    //void compareOverOpsNoMask();
+
+    //void mask_test(); //OK
+    //void alpha_test();
+    //void colors_test(); //OK
+    //void channels_test();
+   // void test_blend();
+
+
+};
+
+class TestColorBlendingWindow: public QDialog, Ui::MainWindow
+{
+    Q_OBJECT
+public:
+    TestColorBlendingWindow(QWidget *parent = 0) : QDialog(parent) {
+        setupUi(this);
+    }
+};
+
+
+
+template<typename channels_type, typename pixel_type, bool alphaLocked, bool allChannelsFlag>
+struct OptimizedOverCompositor32 {
+    struct OptionalParams {
+        OptionalParams(const KoCompositeOp::ParameterInfo& params)
+            : channelFlags(params.channelFlags)
+        {
+        }
+        const QBitArray &channelFlags;
+    };
+
+    template<bool haveMask, bool src_aligned, Vc::Implementation _impl>
+    static ALWAYS_INLINE void compositeVector(const quint8 *src,
+                                              quint8 *dst, const quint8 *mask,
+                                              float opacity, const OptionalParams &oparams)
+    {
+        Q_UNUSED(oparams);
+
+        Vc::uint16_v src_alpha;
+        Vc::uint16_v dst_alpha;
+
+        src_alpha = KoStreamedMath<_impl>::template fetch_alpha_uint16<src_aligned>(src);
+
+
+        bool haveOpacity = opacity != 1;
+        Vc::uint16_v opacity_norm_vec(opacity);
+
+        Vc::uint16_v uint8Max(255);
+        Vc::uint16_v uint8MaxRec1(1/255);
+        Vc::uint16_v zeroValue(Vc::Zero);
+        Vc::uint16_v oneValue(Vc::One);
+
+        src_alpha *= opacity_norm_vec;
+
+        if (haveMask) {
+            Vc::uint16_v mask_vec = KoStreamedMath<_impl>::fetch_mask_8_uint16(mask);
+            src_alpha *= mask_vec * uint8MaxRec1;
+        }
+
+        // The source cannot change the colors in the destination,
+        // since its fully transparent
+        if ((src_alpha == zeroValue).isFull()) {
+            return;
+        }
+
+        dst_alpha = KoStreamedMath<_impl>::template fetch_alpha_uint16<true>(dst);
+
+        Vc::uint16_v src_c1;
+        Vc::uint16_v src_c2;
+        Vc::uint16_v src_c3;
+
+        Vc::uint16_v dst_c1;
+        Vc::uint16_v dst_c2;
+        Vc::uint16_v dst_c3;
+
+
+        KoStreamedMath<_impl>::template fetch_colors_uint16<src_aligned>(src, src_c1, src_c2, src_c3);
+        Vc::uint16_v src_blend;
+        Vc::uint16_v new_alpha;
+
+        if ((dst_alpha == uint8Max).isFull()) {
+            new_alpha = dst_alpha;
+            src_blend = src_alpha * uint8MaxRec1;
+        } else if ((dst_alpha == zeroValue).isFull()) {
+            new_alpha = src_alpha;
+            src_blend = oneValue;
+        } else {
+            /**
+             * The value of new_alpha can have *some* zero values,
+             * which will result in NaN values while division. But
+             * when converted to integers these NaN values will
+             * be converted to zeroes, which is exactly what we need
+             */
+            new_alpha = dst_alpha + (uint8Max - dst_alpha) * src_alpha * uint8MaxRec1;
+
+            src_blend = src_alpha / new_alpha;
+
+
+        }
+
+        if (!(src_blend == oneValue).isFull()) {
+            KoStreamedMath<_impl>::template fetch_colors_uint16<true>(dst, dst_c1, dst_c2, dst_c3);
+
+            dst_c1 = src_blend * (src_c1 - dst_c1) + dst_c1;
+            dst_c2 = src_blend * (src_c2 - dst_c2) + dst_c2;
+            dst_c3 = src_blend * (src_c3 - dst_c3) + dst_c3;
+
+        } else {
+            if (!haveMask && !haveOpacity) {
+                memcpy(dst, src, 4 * Vc::uint16_v::size());
+                return;
+            } else {
+                // opacity has changed the alpha of the source,
+                // so we can't just memcpy the bytes
+                dst_c1 = src_c1;
+                dst_c2 = src_c2;
+                dst_c3 = src_c3;
+            }
+        }
+
+        KoStreamedMath<_impl>::write_channels_uint16(dst, new_alpha, dst_c1, dst_c2, dst_c3);
+
+    }
+
+    template <bool haveMask, Vc::Implementation _impl>
+    static ALWAYS_INLINE void compositeOnePixelScalar(const channels_type *src,
+                                                      channels_type *dst, const quint8 *mask,
+                                                      float opacity, const OptionalParams &oparams)
+    {
+        using namespace Arithmetic;
+        const qint32 alpha_pos = 3;
+
+        const quint8 uint8Rec1 = 1 / 255;
+        const quint8 uint8Max = 255;
+
+        quint8 srcAlpha = src[alpha_pos];
+        srcAlpha *= opacity;
+
+        if (haveMask) {
+            srcAlpha *= quint8(*mask) * uint8Rec1;
+        }
+
+        if (srcAlpha != 0.0) {
+
+            float dstAlpha = dst[alpha_pos];
+            float srcBlendNorm;
+
+            if (dstAlpha == uint8Max) {
+                srcBlendNorm = srcAlpha * uint8Rec1;
+            } else if (dstAlpha == 0.0) {
+                dstAlpha = srcAlpha;
+                srcBlendNorm = 1.0;
+
+                if (!allChannelsFlag) {
+                    pixel_type *d = reinterpret_cast<pixel_type*>(dst);
+                    *d = 0; // dstAlpha is already null
+                }
+            } else {
+                dstAlpha += (uint8Max - dstAlpha) * srcAlpha * uint8Rec1;
+
+                // Optimized version of:
+                //     srcBlendNorm = srcAlpha / dstAlpha);
+                srcBlendNorm = OptiDiv<_impl>::divScalar(srcAlpha, dstAlpha);
+
+
+            }
+
+            if(allChannelsFlag) {
+                if (srcBlendNorm == 1.0) {
+                    if (!alphaLocked) {
+                        const pixel_type *s = reinterpret_cast<const pixel_type*>(src);
+                        pixel_type *d = reinterpret_cast<pixel_type*>(dst);
+                        *d = *s;
+                    } else {
+                        dst[0] = src[0];
+                        dst[1] = src[1];
+                        dst[2] = src[2];
+                    }
+                } else if (srcBlendNorm != 0.0){
+                    dst[0] = KoStreamedMath<_impl>::lerp_mixed_u8_float(dst[0], src[0], srcBlendNorm);
+                    dst[1] = KoStreamedMath<_impl>::lerp_mixed_u8_float(dst[1], src[1], srcBlendNorm);
+                    dst[2] = KoStreamedMath<_impl>::lerp_mixed_u8_float(dst[2], src[2], srcBlendNorm);
+                }
+            } else {
+                const QBitArray &channelFlags = oparams.channelFlags;
+
+                if (srcBlendNorm == 1.0) {
+                    if(channelFlags.at(0)) dst[0] = src[0];
+                    if(channelFlags.at(1)) dst[1] = src[1];
+                    if(channelFlags.at(2)) dst[2] = src[2];
+                } else if (srcBlendNorm != 0.0) {
+                    if(channelFlags.at(0)) dst[0] = KoStreamedMath<_impl>::lerp_mixed_u8_float(dst[0], src[0], srcBlendNorm);
+                    if(channelFlags.at(1)) dst[1] = KoStreamedMath<_impl>::lerp_mixed_u8_float(dst[1], src[1], srcBlendNorm);
+                    if(channelFlags.at(2)) dst[2] = KoStreamedMath<_impl>::lerp_mixed_u8_float(dst[2], src[2], srcBlendNorm);
+                }
+            }
+
+            if (!alphaLocked) {
+                dst[alpha_pos] = KoStreamedMath<_impl>::round_float_to_uint(dstAlpha);
+            }
+        }
+    }
+
+};
+
+/**
+ * An optimized version of a composite op for the use in 4 byte
+ * colorspaces with alpha channel placed at the last byte of
+ * the pixel: C1_C2_C3_A.
+ */
+template<Vc::Implementation _impl>
+class KoDoubleOptimizedCompositeOpOver32 : public KoCompositeOp
+{
+public:
+    KoDoubleOptimizedCompositeOpOver32(const KoColorSpace* cs)
+        : KoCompositeOp(cs, COMPOSITE_OVER, i18n("Normal"), KoCompositeOp::categoryMix()) {}
+
+    using KoCompositeOp::composite;
+
+    virtual void composite(const KoCompositeOp::ParameterInfo& params) const
+    {
+        if(params.maskRowStart) {
+            composite<true>(params);
+        } else {
+            composite<false>(params);
+        }
+    }
+
+    template <bool haveMask>
+    inline void composite(const KoCompositeOp::ParameterInfo& params) const {
+        if (params.channelFlags.isEmpty() ||
+            params.channelFlags == QBitArray(4, true)) {
+
+            KoStreamedMath<_impl>::template genericComposite32<haveMask, false, OptimizedOverCompositor32<quint8, quint32, false, true> >(params);
+        } else {
+            const bool allChannelsFlag =
+                params.channelFlags.at(0) &&
+                params.channelFlags.at(1) &&
+                params.channelFlags.at(2);
+
+            const bool alphaLocked =
+                !params.channelFlags.at(3);
+
+            if (allChannelsFlag && alphaLocked) {
+                KoStreamedMath<_impl>::template genericComposite32_novector<haveMask, false, OptimizedOverCompositor32<quint8, quint32, true, true> >(params);
+            } else if (!allChannelsFlag && !alphaLocked) {
+                KoStreamedMath<_impl>::template genericComposite32_novector<haveMask, false, OptimizedOverCompositor32<quint8, quint32, false, false> >(params);
+            } else /*if (!allChannelsFlag && alphaLocked) */{
+                KoStreamedMath<_impl>::template genericComposite32_novector<haveMask, false, OptimizedOverCompositor32<quint8, quint32, true, false> >(params);
+            }
+        }
+    }
+};
+
+
+#endif // TESTCOLORBLENDING_H
diff --git a/libs/pigment/tests/TestColorBlendingWindow.ui b/libs/pigment/tests/TestColorBlendingWindow.ui
new file mode 100644
index 0000000..ae59111
--- /dev/null
+++ b/libs/pigment/tests/TestColorBlendingWindow.ui
@@ -0,0 +1,343 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>MainWindow</class>
+ <widget class="QDialog" name="MainWindow">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>800</width>
+    <height>600</height>
+   </rect>
+  </property>
+  <property name="font">
+   <font>
+    <family>Tlwg Mono</family>
+   </font>
+  </property>
+  <property name="windowTitle">
+   <string>Alpha Blending in RGBA</string>
+  </property>
+  <property name="windowIcon">
+   <iconset>
+    <normaloff>../../../../pics/icon-kritasketch-256.png</normaloff>../../../../pics/icon-kritasketch-256.png</iconset>
+  </property>
+  <widget class="QWidget" name="centralwidget" native="true">
+   <property name="geometry">
+    <rect>
+     <x>0</x>
+     <y>0</y>
+     <width>801</width>
+     <height>601</height>
+    </rect>
+   </property>
+   <widget class="QRadioButton" name="radio_numer">
+    <property name="geometry">
+     <rect>
+      <x>20</x>
+      <y>10</y>
+      <width>281</width>
+      <height>23</height>
+     </rect>
+    </property>
+    <property name="text">
+     <string>Use numerical interpretation</string>
+    </property>
+    <property name="checked">
+     <bool>false</bool>
+    </property>
+   </widget>
+   <widget class="QRadioButton" name="radio_visual">
+    <property name="geometry">
+     <rect>
+      <x>510</x>
+      <y>10</y>
+      <width>281</width>
+      <height>23</height>
+     </rect>
+    </property>
+    <property name="text">
+     <string>Use visual interpretation</string>
+    </property>
+    <property name="checked">
+     <bool>true</bool>
+    </property>
+   </widget>
+   <widget class="Line" name="line">
+    <property name="geometry">
+     <rect>
+      <x>390</x>
+      <y>60</y>
+      <width>20</width>
+      <height>261</height>
+     </rect>
+    </property>
+    <property name="orientation">
+     <enum>Qt::Vertical</enum>
+    </property>
+   </widget>
+   <widget class="Line" name="line_2">
+    <property name="geometry">
+     <rect>
+      <x>10</x>
+      <y>330</y>
+      <width>371</width>
+      <height>16</height>
+     </rect>
+    </property>
+    <property name="orientation">
+     <enum>Qt::Horizontal</enum>
+    </property>
+   </widget>
+   <widget class="Line" name="line_3">
+    <property name="geometry">
+     <rect>
+      <x>420</x>
+      <y>330</y>
+      <width>371</width>
+      <height>16</height>
+     </rect>
+    </property>
+    <property name="orientation">
+     <enum>Qt::Horizontal</enum>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="r1_view">
+    <property name="geometry">
+     <rect>
+      <x>80</x>
+      <y>70</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label">
+    <property name="geometry">
+     <rect>
+      <x>50</x>
+      <y>70</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>R</string>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_3">
+    <property name="geometry">
+     <rect>
+      <x>50</x>
+      <y>150</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>B</string>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="b1_view">
+    <property name="geometry">
+     <rect>
+      <x>80</x>
+      <y>150</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_2">
+    <property name="geometry">
+     <rect>
+      <x>50</x>
+      <y>110</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>G</string>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="g1_view">
+    <property name="geometry">
+     <rect>
+      <x>80</x>
+      <y>110</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_4">
+    <property name="geometry">
+     <rect>
+      <x>50</x>
+      <y>190</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>A</string>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="a1_view">
+    <property name="geometry">
+     <rect>
+      <x>80</x>
+      <y>190</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="g2_view">
+    <property name="geometry">
+     <rect>
+      <x>680</x>
+      <y>100</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="b2_view">
+    <property name="geometry">
+     <rect>
+      <x>680</x>
+      <y>140</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_5">
+    <property name="geometry">
+     <rect>
+      <x>740</x>
+      <y>100</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>G</string>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_6">
+    <property name="geometry">
+     <rect>
+      <x>740</x>
+      <y>180</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>A</string>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="a2_view">
+    <property name="geometry">
+     <rect>
+      <x>680</x>
+      <y>180</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_7">
+    <property name="geometry">
+     <rect>
+      <x>740</x>
+      <y>140</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>B</string>
+    </property>
+   </widget>
+   <widget class="QLabel" name="label_8">
+    <property name="geometry">
+     <rect>
+      <x>740</x>
+      <y>60</y>
+      <width>21</width>
+      <height>21</height>
+     </rect>
+    </property>
+    <property name="font">
+     <font>
+      <pointsize>20</pointsize>
+     </font>
+    </property>
+    <property name="text">
+     <string>R</string>
+    </property>
+   </widget>
+   <widget class="QGraphicsView" name="r2_view">
+    <property name="geometry">
+     <rect>
+      <x>680</x>
+      <y>60</y>
+      <width>41</width>
+      <height>21</height>
+     </rect>
+    </property>
+   </widget>
+  </widget>
+  <widget class="QStatusBar" name="statusbar">
+   <property name="geometry">
+    <rect>
+     <x>0</x>
+     <y>0</y>
+     <width>3</width>
+     <height>24</height>
+    </rect>
+   </property>
+  </widget>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/plugins/impex/CMakeLists.txt b/plugins/impex/CMakeLists.txt
index e07d48a..85a1a05 100644
--- a/plugins/impex/CMakeLists.txt
+++ b/plugins/impex/CMakeLists.txt
@@ -28,7 +28,7 @@ if(Poppler_Qt5_FOUND)
 endif()
 
 if(LIBRAW_FOUND)
-    add_subdirectory(raw)
+   #add_subdirectory(raw)
 endif()
 
 add_subdirectory(svg)
